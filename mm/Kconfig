menu "Memory Management options"

menu "SLAB allocator options"

choice
	prompt "Choose SLAB allocator"
	default SLUB

config SLUB
	bool "SLUB (Unqueued Allocator)"
	select HAVE_HARDENED_USERCOPY_ALLOCATOR

endchoice

endmenu # SLAB allocator options

config SELECT_MEMORY_MODEL
	def_bool y
	depends on ARCH_SELECT_MEMORY_MODEL

config SPARSEMEM
	def_bool y
	depends on (!SELECT_MEMORY_MODEL && ARCH_SPARSEMEM_ENABLE) || SPARSEMEM_MANUAL

config SPARSEMEM_EXTREME
	def_bool y
	depends on SPARSEMEM && !SPARSEMEM_STATIC

config SPARSEMEM_VMEMMAP_ENABLE
	bool

config SPARSEMEM_VMEMMAP
	bool "Sparse Memory virtual memmap"
	depends on SPARSEMEM && SPARSEMEM_VMEMMAP_ENABLE
	default y

config EXCLUSIVE_SYSTEM_RAM
	def_bool y
	depends on !DEVMEM || STRICT_DEVMEM

config ARCH_ENABLE_MEMORY_HOTPLUG
	bool

menuconfig MEMORY_HOTPLUG
	bool "Memory hotplug"
	select MEMORY_ISOLATION
	depends on SPARSEMEM
	depends on ARCH_ENABLE_MEMORY_HOTPLUG
	depends on 64BIT
	select NUMA_KEEP_MEMINFO if NUMA

if MEMORY_HOTPLUG

endif # MEMORY_HOTPLUG

config SPLIT_PTLOCK_CPUS
	int
	default "999999" if !MMU
	default "999999" if ARM && !CPU_CACHE_VIPT
	default "999999" if PARISC && !PA20
	default "999999" if SPARC32
	default "4"

config ARCH_ENABLE_SPLIT_PMD_PTLOCK
	bool

config PHYS_ADDR_T_64BIT
	def_bool 64BIT

config VIRT_TO_BUS
	bool

config DEFAULT_MMAP_MIN_ADDR
	int "Low address space to protect from user allocation"
	depends on MMU
	default 4096

config ARCH_WANT_GENERAL_HUGETLB
	bool

config ARCH_WANTS_THP_SWAP
	def_bool n

menuconfig TRANSPARENT_HUGEPAGE
	bool "Transparent Hugepage Support"
	depends on HAVE_ARCH_TRANSPARENT_HUGEPAGE && !PREEMPT_RT
	select COMPACTION
	select XARRAY_MULTI
	help
	  Transparent Hugepages allows the kernel to use huge pages and
	  huge tlb transparently to the applications whenever possible.
	  This feature can improve computing performance to certain
	  applications by speeding up page faults during memory
	  allocation, by reducing the number of tlb misses and by speeding
	  up the pagetable walking.

	  If memory constrained on embedded, you may want to say N.

if TRANSPARENT_HUGEPAGE

choice
	prompt "Transparent Hugepage Support sysfs defaults"
	depends on TRANSPARENT_HUGEPAGE
	default TRANSPARENT_HUGEPAGE_ALWAYS
	help
	  Selects the sysfs defaults for Transparent Hugepage Support.

	config TRANSPARENT_HUGEPAGE_ALWAYS
		bool "always"
	help
	  Enabling Transparent Hugepage always, can increase the
	  memory footprint of applications without a guaranteed
	  benefit but it will work automatically for all applications.

	config TRANSPARENT_HUGEPAGE_MADVISE
		bool "madvise"
	help
	  Enabling Transparent Hugepage madvise, will only provide a
	  performance improvement benefit to the applications using
	  madvise(MADV_HUGEPAGE) but it won't risk to increase the
	  memory footprint of applications without a guaranteed
	  benefit.
endchoice

config THP_SWAP
	def_bool y
	depends on TRANSPARENT_HUGEPAGE && ARCH_WANTS_THP_SWAP && SWAP
	help
	  Swap transparent huge pages in one piece, without splitting.
	  XXX: For now, swap cluster backing transparent huge page
	  will be split after swapout.

	  For selection by architectures with reasonable THP sizes.

config READ_ONLY_THP_FOR_FS
	bool "Read-only THP for filesystems (EXPERIMENTAL)"
	depends on TRANSPARENT_HUGEPAGE && SHMEM

	help
	  Allow khugepaged to put read-only file-backed pages in THP.

	  This is marked experimental because it is a new feature. Write
	  support of file THPs will be developed in the next few release
	  cycles.

endif # TRANSPARENT_HUGEPAGE

#
# UP and nommu archs use km based percpu allocator
#
config NEED_PER_CPU_KM
	depends on !SMP || !MMU
	bool
	default y

config NEED_PER_CPU_EMBED_FIRST_CHUNK
	bool

config NEED_PER_CPU_PAGE_FIRST_CHUNK
	bool

config USE_PERCPU_NUMA_NODE_ID
	bool

config HAVE_SETUP_PER_CPU_AREA
	bool

config FRONTSWAP
	bool

config CMA
	bool "Contiguous Memory Allocator"
	depends on MMU
	select MIGRATION
	select MEMORY_ISOLATION
	help
	  This enables the Contiguous Memory Allocator which allows other
	  subsystems to allocate big physically-contiguous blocks of memory.
	  CMA reserves a region of memory and allows only movable pages to
	  be allocated from it. This way, the kernel can use the memory for
	  pagecache and when a subsystem requests for contiguous area, the
	  allocated pages are migrated away to serve the contiguous request.

	  If unsure, say "n".

config CMA_DEBUG
	bool "CMA debug messages (DEVELOPMENT)"
	depends on DEBUG_KERNEL && CMA
	help
	  Turns on debug messages in CMA.  This produces KERN_DEBUG
	  messages for every CMA call as well as various messages while
	  processing calls such as dma_alloc_from_contiguous().
	  This option does not affect warning and error messages.

config CMA_DEBUGFS
	bool "CMA debugfs interface"
	depends on CMA && DEBUG_FS
	help
	  Turns on the DebugFS interface for CMA.

config CMA_SYSFS
	bool "CMA information through sysfs interface"
	depends on CMA && SYSFS
	help
	  This option exposes some sysfs attributes to get information
	  from CMA.

config CMA_AREAS
	int "Maximum count of the CMA areas"
	depends on CMA
	default 19 if NUMA
	default 7
	help
	  CMA allows to create CMA areas for particular purpose, mainly,
	  used as device private area. This parameter sets the maximum
	  number of CMA area in the system.

	  If unsure, leave the default value "7" in UMA and "19" in NUMA.

config MEM_SOFT_DIRTY
	bool "Track memory changes"
	depends on CHECKPOINT_RESTORE && HAVE_ARCH_SOFT_DIRTY && PROC_FS
	select PROC_PAGE_MONITOR
	help
	  This option enables memory changes tracking by introducing a
	  soft-dirty bit on pte-s. This bit it set when someone writes
	  into a page just as regular dirty bit, but unlike the latter
	  it can be cleared by hands.

	  See Documentation/admin-guide/mm/soft-dirty.rst for more details.

config GENERIC_EARLY_IOREMAP
	bool

config STACK_MAX_DEFAULT_SIZE_MB
	int "Default maximum user stack size for 32-bit processes (MB)"
	default 100
	range 8 2048
	depends on STACK_GROWSUP && (!64BIT || COMPAT)
	help
	  This is the maximum stack size in Megabytes in the VM layout of 32-bit
	  user processes when the stack grows upwards (currently only on parisc
	  arch) when the RLIMIT_STACK hard limit is unlimited.

	  A sane initial value is 100 MB.

config DEFERRED_STRUCT_PAGE_INIT
	bool "Defer initialisation of struct pages to kthreads"
	depends on SPARSEMEM
	depends on !NEED_PER_CPU_KM
	depends on 64BIT
	select PADATA
	help
	  Ordinarily all struct pages are initialised during early boot in a
	  single thread. On very large machines this can take a considerable
	  amount of time. If this option is set, large machines will bring up
	  a subset of memmap at boot and then initialise the rest in parallel.
	  This has a potential performance impact on tasks running early in the
	  lifetime of the system until these kthreads finish the
	  initialisation.

config PAGE_IDLE_FLAG
	bool
	select PAGE_EXTENSION if !64BIT
	help
	  This adds PG_idle and PG_young flags to 'struct page'.  PTE Accessed
	  bit writers can set the state of the bit in the flags so that PTE
	  Accessed bit readers may avoid disturbance.

config IDLE_PAGE_TRACKING
	bool "Enable idle page tracking"
	depends on SYSFS && MMU
	select PAGE_IDLE_FLAG
	help
	  This feature allows to estimate the amount of user pages that have
	  not been touched during a given period of time. This information can
	  be useful to tune memory cgroup limits and/or for job placement
	  within a compute cluster.

	  See Documentation/admin-guide/mm/idle_page_tracking.rst for
	  more details.

config ARCH_HAS_CACHE_LINE_SIZE
	bool

config ARCH_HAS_CURRENT_STACK_POINTER
	bool
	help
	  In support of HARDENED_USERCOPY performing stack variable lifetime
	  checking, an architecture-agnostic way to find the stack pointer
	  is needed. Once an architecture defines an unsigned long global
	  register alias named "current_stack_pointer", this config can be
	  selected.

config ARCH_HAS_VM_GET_PAGE_PROT
	bool

config ARCH_HAS_PTE_DEVMAP
	bool

config ARCH_HAS_ZONE_DMA_SET
	bool

config ZONE_DMA
	bool "Support DMA zone" if ARCH_HAS_ZONE_DMA_SET
	default y if ARM64 || X86

config ZONE_DMA32
	bool "Support DMA32 zone" if ARCH_HAS_ZONE_DMA_SET
	depends on !X86_32
	default y if ARM64

config ZONE_DEVICE
	bool "Device memory (pmem, HMM, etc...) hotplug support"
	depends on MEMORY_HOTPLUG
	depends on MEMORY_HOTREMOVE
	depends on SPARSEMEM_VMEMMAP
	depends on ARCH_HAS_PTE_DEVMAP
	select XARRAY_MULTI

	help
	  Device memory hotplug support allows for establishing pmem,
	  or other device driver discovered memory regions, in the
	  memmap. This allows pfn_to_page() lookups of otherwise
	  "device-physical" addresses which is needed for using a DAX
	  mapping in an O_DIRECT operation, among other things.

	  If FS_DAX is enabled, then say Y.

#
# Helpers to mirror range of the CPU page tables of a process into device page
# tables.
#
config HMM_MIRROR
	bool
	depends on MMU

config DEVICE_PRIVATE
	bool "Unaddressable device memory (GPU memory, ...)"
	depends on ZONE_DEVICE

	help
	  Allows creation of struct pages to represent unaddressable device
	  memory; i.e., memory that is only accessible from the device (or
	  group of devices). You likely also want to select HMM_MIRROR.

config VMAP_PFN
	bool

config ARCH_USES_HIGH_VMA_FLAGS
	bool
config ARCH_HAS_PKEYS
	bool

config VM_EVENT_COUNTERS
	default y
	bool "Enable VM event counters for /proc/vmstat" if EXPERT
	help
	  VM event counters are needed for event counts to be shown.
	  This option allows the disabling of the VM event counters
	  on EXPERT systems.  /proc/vmstat will only show page counts
	  if VM event counters are disabled.

config PERCPU_STATS
	bool "Collect percpu memory statistics"
	help
	  This feature collects and exposes statistics via debugfs. The
	  information includes global and per chunk statistics, which can
	  be used to help understand percpu memory usage.

config GUP_TEST
	bool "Enable infrastructure for get_user_pages()-related unit tests"
	depends on DEBUG_FS
	help
	  Provides /sys/kernel/debug/gup_test, which in turn provides a way
	  to make ioctl calls that can launch kernel-based unit tests for
	  the get_user_pages*() and pin_user_pages*() family of API calls.

	  These tests include benchmark testing of the _fast variants of
	  get_user_pages*() and pin_user_pages*(), as well as smoke tests of
	  the non-_fast variants.

	  There is also a sub-test that allows running dump_page() on any
	  of up to eight pages (selected by command line args) within the
	  range of user-space addresses. These pages are either pinned via
	  pin_user_pages*(), or pinned via get_user_pages*(), as specified
	  by other command line arguments.

	  See tools/testing/selftests/vm/gup_test.c

comment "GUP_TEST needs to have DEBUG_FS enabled"
	depends on !GUP_TEST && !DEBUG_FS

config GUP_GET_PTE_LOW_HIGH
	bool

config ARCH_HAS_PTE_SPECIAL
	bool

#
# Some architectures require a special hugepage directory format that is
# required to support multiple hugepage sizes. For example a4fe3ce76
# "powerpc/mm: Allow more flexible layouts for hugepage pagetables"
# introduced it on powerpc.  This allows for a more flexible hugepage
# pagetable layouts.
#
config ARCH_HAS_HUGEPD
	bool

config MAPPING_DIRTY_HELPERS
        bool

config KMAP_LOCAL
	bool

config KMAP_LOCAL_NON_LINEAR_PTE_ARRAY
	bool

# struct io_mapping based helper.  Selected by drivers that need them
config IO_MAPPING
	bool

config SECRETMEM
	def_bool ARCH_HAS_SET_DIRECT_MAP && !EMBEDDED

config ANON_VMA_NAME
	bool "Anonymous VMA name support"
	depends on PROC_FS && ADVISE_SYSCALLS && MMU

	help
	  Allow naming anonymous virtual memory areas.

	  This feature allows assigning names to virtual memory areas. Assigned
	  names can be later retrieved from /proc/pid/maps and /proc/pid/smaps
	  and help identifying individual anonymous memory areas.
	  Assigning a name to anonymous virtual memory area might prevent that
	  area from being merged with adjacent virtual memory areas due to the
	  difference in their name.

config USERFAULTFD
	bool "Enable userfaultfd() system call"
	depends on MMU
	help
	  Enable the userfaultfd() system call that allows to intercept and
	  handle page faults in userland.

config HAVE_ARCH_USERFAULTFD_WP
	bool
	help
	  Arch has userfaultfd write protection support

config HAVE_ARCH_USERFAULTFD_MINOR
	bool
	help
	  Arch has userfaultfd minor fault support

config PTE_MARKER
	bool

	help
	  Allows to create marker PTEs for file-backed memory.

config PTE_MARKER_UFFD_WP
	bool "Userfaultfd write protection support for shmem/hugetlbfs"
	default y
	depends on HAVE_ARCH_USERFAULTFD_WP
	select PTE_MARKER

	help
	  Allows to create marker PTEs for userfaultfd write protection
	  purposes.  It is required to enable userfaultfd write protection on
	  file-backed memory types like shmem and hugetlbfs.

endmenu
