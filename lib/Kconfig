config BINARY_PRINTF
	def_bool n

menu "Library routines"

config BITREVERSE
	tristate

config GENERIC_STRNCPY_FROM_USER
	def_bool !ARCH_HAS_STRNCPY_FROM_USER

config GENERIC_STRNLEN_USER
	def_bool !ARCH_HAS_STRNLEN_USER

config GENERIC_NET_UTILS
	bool

source "lib/math/Kconfig"

config GENERIC_PCI_IOMAP
	bool

config GENERIC_IOMAP
	bool
	select GENERIC_PCI_IOMAP

config ARCH_USE_CMPXCHG_LOCKREF
	bool

config ARCH_HAS_FAST_MULTIPLIER
	bool

config ARCH_USE_SYM_ANNOTATIONS
	bool

source "lib/crypto/Kconfig"

config CRC16
	tristate "CRC16 functions"

config CRC32
	tristate "CRC32/CRC32c functions"
	default y
	select BITREVERSE

config CRC32_SELFTEST
	tristate "CRC32 perform self test on init"
	depends on CRC32

choice
	prompt "CRC32 implementation"
	depends on CRC32
	default CRC32_SLICEBY8

config CRC32_SLICEBY8
	bool "Slice by 8 bytes"

endchoice

config HAS_IOMEM
	bool
	depends on !NO_IOMEM
	default y

config HAS_IOPORT_MAP
	bool
	depends on HAS_IOMEM && !NO_IOPORT_MAP
	default y

source "kernel/dma/Kconfig"

config SGL_ALLOC
	bool
	default n

config IOMMU_HELPER
	bool

config CHECK_SIGNATURE
	bool

config CPUMASK_OFFSTACK
	bool "Force CPU masks off stack" if DEBUG_PER_CPU_MAPS
	help
	  Use dynamic allocation for cpumask_var_t, instead of putting
	  them on the stack.  This is a bit more expensive, but avoids
	  stack overflow.

config CPU_RMAP
	bool
	depends on SMP

config DQL
	bool

config NLATTR
	bool

source "lib/vdso/Kconfig"

config SG_POOL
	def_bool n

config ARCH_HAS_PMEM_API
	bool


config ARCH_HAS_UACCESS_FLUSHCACHE
	bool

config ARCH_HAS_COPY_MC
	bool

config ARCH_STACKWALK
       bool

config STACKDEPOT
	bool
	select STACKTRACE

config STACK_HASH_ORDER
	int "stack depot hash size (12 => 4KB, 20 => 1024KB)"
	range 12 20
	default 20
	depends on STACKDEPOT


config SBITMAP
	bool
endmenu
